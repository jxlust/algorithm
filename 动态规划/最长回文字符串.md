### 解法1 暴力枚举
代码：
```javascript
/**
 * @param {string} s
 * @return {string}
 */
var longestPalindrome = function (s) {

  const isValid = function (s, left, right) {
    while (left < right) {
      if (s[left] === s[right]) {
        left++;
        right--;
      } else {
        return false;
      }
    }
    return true;
  }
  if (s.length < 2) return s;
  let maxLength = 1,
    start = 0;
  for (let i = 0; i < s.length; i++) {
    for (let j = 1; j < s.length; j++) {
      if (j - i + 1 > maxLength && isValid(s, i, j)) {
        //更新
        maxLength = j - i + 1;
        start = i;
      }
    }
  }

  return s.substr(start, maxLength)
};
```

### 解法2 动态规划
代码
```javascript
/**
 * @param {string} s
 * @return {string}
 */
var longestPalindrome = function (s) {
  // 表示从i 到j 的字符串是否为回文字符串
  //  dp[i][j] = (s[i] === s[j]) && dp[i+1][j-1]
  // i <=j
  if (s.length < 2) return s;
  let dp = new Array(s.length);
  for (let i = 0; i < s.length; i++) {
    dp[i] = new Array(s.length);
    dp[i][i] = true;
  }
  let maxLength = 1,
    start = 0;
  for (let j = 1; j < s.length; j++) {
    for (let i = 0; i < j; i++) {
      if (s[i] != s[j]) {
        dp[i][j] = false;
      } else {
        if (j - i <= 2) {
          dp[i][j] = true;
        } else {
          dp[i][j] = dp[i + 1][j - 1];
        }
      }

      if (dp[i][j] && j - i + 1 > maxLength) {
        maxLength = j - i + 1;
        start = i;
      }
    }
  }
  return s.substr(start, maxLength)

};

/**
 * @param {string} s
 * @return {string}
 */
var longestPalindrome = function (s) {
  // 表示从i 到j 的字符串是否为回文字符串
  //  dp[i][j] = (s[i] === s[j]) && dp[i+1][j-1]
  // i <=j
  if (s.length < 2) return s;
  let res = '';
  let dp = new Array(s.length);
  for (let i = 0; i < s.length; i++) {
    dp[i] = new Array(s.length);
  }
  for (let l = 0; l < s.length; l++) {
    for (let i = 0; i < s.length; i++) {
      let j = i + l;
      if (j >= s.length) break;
      if (l === 0) {
        dp[i][j] = true;
      } else if (l <= 2) {
        dp[i][j] = s[i] === s[j]
      } else {
        dp[i][j] = s[i] === s[j] && dp[i + 1][j - 1]
      }
      if (dp[i][j] && res.length < l + 1) {
        res = s.substring(i, j + 1)
      }
    }
  }

  return res;

};

```
### 解法3 中心扩散
代码
```javascript
/**
 * 中心扩散
 * @param {string} s
 * @return {string}
 */
var longestPalindrome = function (s) {
  var getSpreadLength = function (left, right) {
    while (left >= 0 && right < s.length && s[left] === s[right]) {
      //继续扩散
      left--;
      right++;
    }
    //结束扩散了
    return right - left - 1;


  }
  // 表示从i 到j 的字符串是否为回文字符串
  if (s.length < 2) return s;
  let start = 0,
    end = 0;
  for (let i = 0; i < s.length; i++) {
    let l1 = getSpreadLength(i, i);
    let l2 = getSpreadLength(i, i + 1);
    let maxl = Math.max(l1, l2);
    if (maxl > end - start + 1) {
      //maxl > end-start 表示的后面的长度相等也会替换掉，生成等长度的新字符串
      start = i - ((maxl - 1) >> 1);
      end = i + (maxl >> 1);
    }
  }
  return s.substring(start, end + 1)

};
```

### 解法4 Manacher 算法

以 abbabb 为例子：

| char  |  #  |  a  |  #  |  b  |  #  | b   | #   | a   | #   | b   | #   | b   | #   |
| :---: | :-: | :-: | :-: | :-: | :-: | --- | --- | --- | --- | --- | --- | --- | --- |
| index |  0  |  1  |  2  |  3  |  4  | 5   | 6   | 7   | 8   | 9   | 10  | 11  | 12  |
|   P   |  0  |  1  |  0  |  1  |  4  | 1   | 0   | 5   | 0   | 1   | 2   | 1   | 0   |

可以写出初始版代码：
```javascript
/**
 * Manacher 初始版 时间复杂度还是O（n^2）
 * @param {string} s
 * @return {string}
 */
var longestPalindrome = function (s) {

  const getSpreadLength = function (center, fillStr) {
    let left = center - 1,
      right = center + 1;
    let step = 0;
    while (left >= 0 && right < fillStr.length && fillStr[left] === fillStr[right]) {
      //继续扩散
      left--;
      right++;
      step++;
    }
    //结束扩散了
    //这里扩散步数即是最长回文字符串的长度 P[index]
    return step;
  }
  const fillString = function (s) {
    let str = '#';
    for (let v of s) {
      str += `${v}#`
    }
    return str;
  }

  if (s.length < 2) return s;
  //把字符串填充使得长度都保证为奇数
  let fillStr = fillString(s);
  let fillLength = 2 * s.length + 1;
  let maxLength = 1,
    start = 0;
  for (let i = 1; i < fillLength; i++) {
    let l = getSpreadLength(i, fillStr);
    if (l > maxLength) {
      maxLength = l;
      start = (i - maxLength) >> 1
    }
  }

  return s.substr(start, maxLength)

};
```

