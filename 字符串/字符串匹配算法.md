### 普通暴力匹配算法

例如：

```
下标i    0  1  2  3  4  5  6  7  8  9
主串S    a  b  a  b  c  a  b  c  a  c
模式串T  a  b  c  a
```

第一次比较，从左到右，S[0] = T[0]，计数器++；比较 S[1] = T[1]，i++；当 s[2] != T[2]，主串回溯，从 S[1]重新开始比较。

代码：

```javascript
const BF = function (str, s) {
  let m = str.length,
    n = s.length
  let i = 0,
    j = 0
  while (i < m && j < n) {
    if (str[i] === s[j]) {
      i++
      j++
    } else {
      //i回溯到开始比较的位置+1
      //j回溯到0重新开始
      i = i - j + 1
      j = 0
    }
  }
  console.log(i, j)
  if (j === n) {
    return i - j
  } else {
    return -1
  }
}
```

### BM 算法

即坏字符规则 和好后缀规则 [参考网站](https://blog.csdn.net/l953972252/article/details/51331001)

1）坏字符规则（Bad Character）：

在 BM 算法从右向左扫描的过程中，若发现某个字符 x 不匹配，则按如下两种情况讨论：

      i.  如果字符x在模式P中没有出现，那么从字符x开始的m个文本显然不可能与P匹配成功，直接全部跳过该区域即可。

      ii. 如果x在模式P中出现，则以该字符进行对齐。

用数学公式表示，设 Skip(x)为 P 右移的距离，m 为模式串 P 的长度，max(x)为字符 x 在 P 中最右位置。

2）好后缀规则（Good Suffix）：

若发现某个字符不匹配的同时，已有部分字符匹配成功，则按如下两种情况讨论：

      i.  如果在P中位置t处已匹配部分P'在P中的某位置t'也出现，且位置t'的前一个字符与位置t的前一个字符不相同，则将P右移使t'对应t方才的所在的位置。

      ii. 如果在P中任何位置已匹配部分P'都没有再出现，则找到与P'的后缀P''相同的P的最长前缀x，向右移动P，使x对应方才P''后缀所在的位置。

用数学公式表示，设Shift(j)为P右移的距离，m为模式串P的长度，j 为当前所匹配的字符位置，s为t'与t的距离（以上情况i）或者x与P''的距离（以上情况ii）。


