## 题目分析

题目：给你两个单词  word1 和  word2，请你计算出将  word1  转换成  word2 所使用的最少操作数  。

分析：

你可以对一个单词进行如下三种操作：

1. 插入一个字符
2. 删除一个字符
3. 替换一个字符

例子：

1. 输入：word1 = "horse", word2 = "ros"
2. 输出：3
3. 解释：

- horse -> rorse (将 'h' 替换为 'r')
- rorse -> rose (删除 'r')
- rose -> ros (删除 'e')

要点：

1. 对于字符串的动态规划问题，定义两个指针 i,j 分别从末尾开始
2. base case
3. 分类讨论，三个操作，插入，删除，替换，求最小值

## 方法 1：递归

> 数据量大运行超时

代码：

```javascript
/**
 * @param {string} word1
 * @param {string} word2
 * @return {number}
 */
var minDistance = function (word1, word2) {
  // horse  =>  ros
  //     i
  //   ros
  //     j

  //base case:
  //1. i === 0 && j === 0 isequal?0:1
  //2. i < 0 return j + 1;//插入
  //3. j < 0 reutrn i + 1;//删除

  //容易得出 s[i] === s[j] 不需要编辑，skip跳过 i--,j--, 等价于 求s[0,i-1] s[0,j-1]的编辑距离
  // 次数 = minDistance (s[0,i-1],s[0,j-1])
  //s[i] != s[j]
  //分类讨论，其实就是计算每种操作，然后取最小距离
  //插入： 次数 = minDistance(s[0,i],s[0,j-1]) + 1

  //删除： 次数 = minDistance(s[0,i-1],s[0,j]) + 1

  //替换： 次数 = minDistance(s[0,i-1],s[0,j-1]) + 1

  //综上 当s[i] != s[j]的时候 次数= Min(minDistance(s[0,i],s[0,j-1]) + 1,minDistance(s[0,i-1],s[0,j]) + 1, minDistance(s[0,i-1],s[0,j-1]) + 1)

  //结束条件： 即是上面的base case

  //上面是自顶向下的递归思路，实现代码如下
  const helper = function (i, j) {
    if (i < 0) return j + 1
    if (j < 0) return i + 1
    if (word1[i] === word2[j]) {
      return helper(--i, --j)
    } else {
      return (
        Math.min(helper(i, j - 1), helper(i - 1, j), helper(i - 1, j - 1)) + 1
      )
    }
  }
  return helper(word1.length - 1, word2.length - 1)
}
```

## 方法2：递归优化-备忘录
> 优化后基本大大优化了执行时间

代码：

```javascript
var minDistance = function (word1, word2) {
  let hashMap = new Map()
  const helper = function (i, j) {
    let key = `${i}-${j}`
    if (hashMap.has(key)) {
      return hashMap.get(key)
    }
    if (i < 0) return j + 1
    if (j < 0) return i + 1
    if (word1[i] === word2[j]) {
      let ret = helper(--i, --j)
      hashMap.set(key, ret)
      return ret
    } else {
      let ret =
        Math.min(helper(i, j - 1), helper(i - 1, j), helper(i - 1, j - 1)) + 1
      hashMap.set(key, ret)
      return ret
    }
  }
  return helper(word1.length - 1, word2.length - 1)
}
```
## 方法3：动态规划
> 自底向上dp table,dp table还可以记录最优的操作路径

例子： horse => ros dp table表格：
![dp表格](./img/dp_table.png)

代码：
```javascript


```